<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mosp LEDA Extension Package: Rank-Maximal Matchings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mosp LEDA Extension Package
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rank-Maximal Matchings</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4a5b62a58c1a83375909a3bed9fef74f"><td class="memItemLeft" align="right" valign="top">leda::list&lt; leda::edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rankmax.html#ga4a5b62a58c1a83375909a3bed9fef74f">mosp::BI_RANK_MAX_MATCHING</a> (leda::graph &amp;G, const leda::edge_array&lt; int &gt; &amp;rank)</td></tr>
<tr class="memdesc:ga4a5b62a58c1a83375909a3bed9fef74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rank-maximal matching of a bipartite graph.  <a href="group__rankmax.html#ga4a5b62a58c1a83375909a3bed9fef74f">More...</a><br /></td></tr>
<tr class="separator:ga4a5b62a58c1a83375909a3bed9fef74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc89daaf4a0fef0d87113709263061d4"><td class="memItemLeft" align="right" valign="top">leda::list&lt; leda::edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rankmax.html#gabc89daaf4a0fef0d87113709263061d4">mosp::BI_RANK_MAX_MATCHING_MWMR</a> (leda::graph &amp;G, const leda::edge_array&lt; int &gt; &amp;rank)</td></tr>
<tr class="memdesc:gabc89daaf4a0fef0d87113709263061d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rank-maximal matching of a bipartite graph.  <a href="group__rankmax.html#gabc89daaf4a0fef0d87113709263061d4">More...</a><br /></td></tr>
<tr class="separator:gabc89daaf4a0fef0d87113709263061d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0cceac1e287a8668b2dfeac5a4d26c"><td class="memItemLeft" align="right" valign="top">leda::list&lt; leda::edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rankmax.html#ga5a0cceac1e287a8668b2dfeac5a4d26c">mosp::DBI_RANK_MAX_MATCHING_MWMR</a> (leda::graph &amp;G, const leda::edge_array&lt; int &gt; &amp;rank)</td></tr>
<tr class="memdesc:ga5a0cceac1e287a8668b2dfeac5a4d26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rank-maximal matching of a bipartite graph.  <a href="group__rankmax.html#ga5a0cceac1e287a8668b2dfeac5a4d26c">More...</a><br /></td></tr>
<tr class="separator:ga5a0cceac1e287a8668b2dfeac5a4d26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f61892392abd693d4d100c02f7fcba5"><td class="memItemLeft" align="right" valign="top">leda::array&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rankmax.html#ga3f61892392abd693d4d100c02f7fcba5">mosp::BI_RANK_MAX_MATCHING_PROFILE</a> (const leda::graph &amp;G, const leda::edge_array&lt; int &gt; &amp;rank, const leda::list&lt; leda::edge &gt; &amp;matching)</td></tr>
<tr class="memdesc:ga3f61892392abd693d4d100c02f7fcba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the profile of a matching.  <a href="group__rankmax.html#ga3f61892392abd693d4d100c02f7fcba5">More...</a><br /></td></tr>
<tr class="separator:ga3f61892392abd693d4d100c02f7fcba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22adfe4c5b4893346ff5c98f605af181"><td class="memItemLeft" align="right" valign="top">leda::list&lt; leda::edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rankmax.html#ga22adfe4c5b4893346ff5c98f605af181">mosp::BI_RANK_MAX_CAPACITATED_MATCHING</a> (const leda::graph &amp;G, const leda::list&lt; leda::node &gt; &amp;A, const leda::list&lt; leda::node &gt; &amp;B, const leda::node_array&lt; int &gt; &amp;capacity, const leda::edge_array&lt; int &gt; &amp;rank)</td></tr>
<tr class="memdesc:ga22adfe4c5b4893346ff5c98f605af181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rank-maximal matching of a bipartite graph with capacities on the right side of the bipartite graph.  <a href="group__rankmax.html#ga22adfe4c5b4893346ff5c98f605af181">More...</a><br /></td></tr>
<tr class="separator:ga22adfe4c5b4893346ff5c98f605af181"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga22adfe4c5b4893346ff5c98f605af181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leda::list&lt;leda::edge&gt; mosp::BI_RANK_MAX_CAPACITATED_MATCHING </td>
          <td>(</td>
          <td class="paramtype">const leda::graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::list&lt; leda::node &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::list&lt; leda::node &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::node_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::edge_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a rank-maximal matching of a bipartite graph with capacities on the right side of the bipartite graph. </p>
<p>The function computes a Rank-Maximal matching <img class="formulaInl" alt="$M$" src="form_0.png"/> of <img class="formulaInl" alt="$G$" src="form_1.png"/>, that is a matching which uses the largest possible number of rank one edges, and subject to this constraint the largest possible number of rank two edges and so on. Nodes on the right side of the partition may be matched multiple times. This is why the user must provide a capacity function on the nodes plus a partition of the nodes such that all edges are from A to B.</p>
<p>The matching is returned as a list of edges. The running time is <img class="formulaInl" alt="$O(n m)$" src="form_12.png"/>.</p>
<p>During the algorithm the input graph is copied and everything happens on the copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">A</td><td>Nodes of the left-side partition of the bipartite graph. </td></tr>
    <tr><td class="paramname">B</td><td>Nodes of the right-side partition of the bipartite graph. </td></tr>
    <tr><td class="paramname">capacity</td><td>Node capacities </td></tr>
    <tr><td class="paramname">rank</td><td>A rank function on the edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>G must be simple, loopfree and bipartite. </dd>
<dd>
rank is a positive integer function on the edges of the graph. </dd>
<dd>
Capacities must be positive. </dd>
<dd>
Capacities of all nodes of the left-side partition must be 1. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The list of edges of the computed matching. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a5b62a58c1a83375909a3bed9fef74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leda::list&lt;leda::edge&gt; mosp::BI_RANK_MAX_MATCHING </td>
          <td>(</td>
          <td class="paramtype">leda::graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::edge_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a rank-maximal matching of a bipartite graph. </p>
<p>The function computes a Rank-Maximal matching <img class="formulaInl" alt="$M$" src="form_0.png"/> of <img class="formulaInl" alt="$G$" src="form_1.png"/>, that is a matching which uses the largest possible number of rank one edges, and subject to this constraint the largest possible number of rank two edges and so on. The matching is returned as a list of edges. The running time is <img class="formulaInl" alt="$O(r \sqrt{n} m)$" src="form_2.png"/> where <img class="formulaInl" alt="$r$" src="form_3.png"/> is the maximum rank of an edge in the input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">rank</td><td>A rank function on the edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>G must be simple, loopfree and bipartite. </dd>
<dd>
rank is a positive integer function on the edges of the graph. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges with the resulting matching. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc89daaf4a0fef0d87113709263061d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leda::list&lt;leda::edge&gt; mosp::BI_RANK_MAX_MATCHING_MWMR </td>
          <td>(</td>
          <td class="paramtype">leda::graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::edge_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a rank-maximal matching of a bipartite graph. </p>
<p>The function computes a Rank-Maximal matching <img class="formulaInl" alt="$M$" src="form_0.png"/> of <img class="formulaInl" alt="$G$" src="form_1.png"/>, that is a matching which uses the largest possible number of rank one edges, and subject to this the largest possible number of rank two edges and so on. The matching is returned as a list of edges. This procedure solves the problem by reducing it to the maximum weight matching problem, and therefore the running time is <img class="formulaInl" alt="$O( n^2 ( m + n \log n ))$" src="form_4.png"/>. The second <img class="formulaInl" alt="$n$" src="form_5.png"/> comes from the possibly large cost of arithmetic since the reduction involves edge weights which can be as large as <img class="formulaInl" alt="$n^n$" src="form_6.png"/>. The space requirement is <img class="formulaInl" alt="$O(mn + n^2)$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">rank</td><td>A rank function on the edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>G must be simple, loopfree and bipartite. </dd>
<dd>
rank is a positive integer function on the edges of the graph. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges with the resulting matching. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f61892392abd693d4d100c02f7fcba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leda::array&lt;int&gt; mosp::BI_RANK_MAX_MATCHING_PROFILE </td>
          <td>(</td>
          <td class="paramtype">const leda::graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::edge_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::list&lt; leda::edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>matching</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the profile of a matching. </p>
<p>The function returns an array <img class="formulaInl" alt="$ar$" src="form_9.png"/> of non-negative integers representing the number of edges of each rank belonging to the matching. This array is indexed from <img class="formulaInl" alt="$1$" src="form_10.png"/> to <img class="formulaInl" alt="$n$" src="form_5.png"/>, where <img class="formulaInl" alt="$n$" src="form_5.png"/> is the number of vertices of <img class="formulaInl" alt="$G$" src="form_1.png"/>. The running time is <img class="formulaInl" alt="$O(n)$" src="form_11.png"/> where <img class="formulaInl" alt="$n$" src="form_5.png"/> is the number of nodes of <img class="formulaInl" alt="$G$" src="form_1.png"/>. Note that this procedure does not check whether the list of edges is really a matching or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The input bipartite graph. </td></tr>
    <tr><td class="paramname">rank</td><td>An edge rank function. </td></tr>
    <tr><td class="paramname">matching</td><td>A matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The profile of the input matching. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>rank is a positive integer function on the edges of the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a0cceac1e287a8668b2dfeac5a4d26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leda::list&lt;leda::edge&gt; mosp::DBI_RANK_MAX_MATCHING_MWMR </td>
          <td>(</td>
          <td class="paramtype">leda::graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const leda::edge_array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a rank-maximal matching of a bipartite graph. </p>
<p>The function computes a Rank-Maximal matching <img class="formulaInl" alt="$M$" src="form_0.png"/> of <img class="formulaInl" alt="$G$" src="form_1.png"/>, that is a matching which uses the largest possible number of rank one edges, and subject to this the largest possible number of rank two edges and so on. The matching is returned as a list of edges. This procedure solves the problem by reducing it to the maximum weight matching problem. The reduction is implicit resulting to a running time of <img class="formulaInl" alt="$(r \sqrt{n} m )$" src="form_8.png"/> where <img class="formulaInl" alt="$r$" src="form_3.png"/> is the maximum rank of an edge in the input and linear space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">rank</td><td>A rank function on the edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>G must be simple, loopfree and bipartite. </dd>
<dd>
rank is a positive integer function on the edges of the graph. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges with the resulting matching. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
