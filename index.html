<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mosp LEDA Extension Package: Library for Matchings with One Sided Preferences</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mosp LEDA Extension Package
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Library for Matchings with One Sided Preferences </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>In <b>M</b>atchings with <b>O</b>ne <b>S</b>ided <b>P</b>references we are given a bipartite graph <img class="formulaInl" alt="$G(V,E)$" src="form_49.png"/> where <img class="formulaInl" alt="$V = \mathcal{A} \cup \mathcal{P}$" src="form_50.png"/>. Set <img class="formulaInl" alt="$\mathcal{A}$" src="form_51.png"/> denotes a set of applicants and set <img class="formulaInl" alt="$\mathcal{P}$" src="form_52.png"/> of posts. Each applicant in <img class="formulaInl" alt="$\mathcal{A}$" src="form_51.png"/> submits a preference list (a ranking of a subset of the posts, possibly including ties). Edges which are choice <img class="formulaInl" alt="$i$" src="form_25.png"/> are called rank <img class="formulaInl" alt="$i$" src="form_25.png"/> edges.</p>
<p>Given this setting we may ask for matchings which satisfy different optimization criteria. This library contains code for the two following such criteria.</p>
<h2><a class="anchor" id="alg_rankmaximal"></a>
Rank-Maximal Matchings</h2>
<p>A rank-maximal matching is a matching which contains the maximum number of first choice edges. Given that constraint it contains the maximum number of second choice edges and so on. A rank-maximal matching can be computed in polynomial time. <b>libMOSP</b> contains three implementations which compute such a matching:</p>
<ul>
<li>An <img class="formulaInl" alt="$O( \min(n+r, r \sqrt{n} ) m )$" src="form_53.png"/> algorithm where <img class="formulaInl" alt="$r$" src="form_3.png"/> is the maximum rank of an edge in the instance. See <a href="http://portal.acm.org/citation.cfm?doid=1198513.1198520">here</a> for a description of the algorithm.</li>
<li>An algorithm with the same running time but based on a different approach (reducing the problem to the weighted matching problem). See <a href="http://dx.doi.org/10.1016/j.tcs.2007.08.004">here</a> for more details.</li>
<li>Again an algorithm which reduces the problem to the weighted matching but this time with slower running time <img class="formulaInl" alt="$O( n^2 ( m + n \log n ) )$" src="form_54.png"/> and more space <img class="formulaInl" alt="$O(mn + n^2)$" src="form_7.png"/>. The extra <img class="formulaInl" alt="$n$" src="form_5.png"/> comes from the possible cost of arithmetic since the algorithm handles numbers up to <img class="formulaInl" alt="$O(n^n)$" src="form_55.png"/>.</li>
</ul>
<p>Except for the above, <b>libMOSP</b> contains an implementation of a rank-maximal matching algorithm with capacities. In this case the nodes of the right-side partition of the bipartite graph may have capacities larger that 1, i.e. they may be matched more than once. The library contains:</p>
<ul>
<li>An <img class="formulaInl" alt="$O( n m)$" src="form_56.png"/> algorithm. See <a href="http://portal.acm.org/citation.cfm?doid=1198513.1198520">here</a> for more details.</li>
</ul>
<h2><a class="anchor" id="alg_popular"></a>
Popular Matchings</h2>
<p>We say that a matching <img class="formulaInl" alt="$M'$" src="form_57.png"/> is more popular than matching <img class="formulaInl" alt="$M$" src="form_0.png"/> if more applicants prefer <img class="formulaInl" alt="$M'$" src="form_57.png"/> than those who prefer <img class="formulaInl" alt="$M$" src="form_0.png"/>. Applicants who are indifferent are ignored. A matching <img class="formulaInl" alt="$M$" src="form_0.png"/> is popular if there is no other matching which is more popular.</p>
<p>Popular matchings can also be computed in polynomial time (see <a href="http://portal.acm.org/citation.cfm?id=1070432.1070491">here</a> for more details), but unfortunately they do not always exist. In that case we wish to compute matchings which approximate the least unpopular matching (see <a href="http://www.springerlink.com/content/e882513747l80372">here</a> for more details).</p>
<p>libMOSP contains two algorithms.</p>
<ul>
<li>An <img class="formulaInl" alt="$O( \sqrt{n} m )$" src="form_58.png"/> algorithm from <a href="http://portal.acm.org/citation.cfm?id=1070432.1070491">here</a> which decides if the instance has a popular matching or not (and possibly returns one).</li>
<li>An algorithm which is a variation of the previous one and is guarantied to return a result even if the instance does not admit a popular matching. See <a href="http://dx.doi.org/10.1007/978-3-540-69903-3_13">here</a> for a more detailed description.</li>
</ul>
<p>libMOSP also provides routines to compute the so called "unpopularity factor" and the "unpopularity margin" of a matching (see McCutchen 2007).</p>
<h2><a class="anchor" id="Instance"></a>
Generators</h2>
<p>The library also contains 4 random structured instance <a class="el" href="group__generator.html">generators</a>.</p>
<h1><a class="anchor" id="req_sec"></a>
Requirements</h1>
<p>This implementation is written in C++ and uses <a href="http://www.algorithmic-solutions.com/enleda.htm">LEDA</a>. The structure of the package follows that of a LEDA extension package (<a href="http://www.algorithmic-solutions.com/enleps.htm">LEP</a>).</p>
<h1><a class="anchor" id="platf_sec"></a>
Supported Platforms</h1>
<p>This package has been tested on the following platforms:</p><ol type="1">
<li>gcc 3.x, 4.0.x and 4.1.x under Linux</li>
<li>gcc 3.x under SunOS 5.9</li>
<li>gcc 3.x under Cygwin</li>
</ol>
<p>but it may work on others too.</p>
<h1><a class="anchor" id="lic_sec"></a>
License</h1>
<pre class="fragment"> This program can be freely used in an academic environment
 ONLY for research purposes, subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    an acknowledgment in the product documentation is required.
 2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.

 Any other use is strictly prohibited by the author, without an explicit
 permission.

 This software is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</pre><p>Note that this package uses LEDA, which is <a href="http://www.algorithmic-solutions.com/enledalizenzen.htm">not free</a>.</p>
<h1><a class="anchor" id="news_sec"></a>
News</h1>
<ul>
<li>01 Feb 2010: v0.7 released<ul>
<li>Added implementation of popular matchings and variations</li>
<li>Added random structures instance generators</li>
<li>Support LEDA 6.0 on linux platforms.</li>
</ul>
</li>
<li>24 Apr 2005: v0.6 released<ul>
<li>Support LEDA 5.0 on win32 platforms with bcc32</li>
</ul>
</li>
<li>23 Feb 2005: v0.5 released<ul>
<li>Support Borland C++ bcc32 (only LEDA 4.5 or earlier)</li>
<li>Minor fixes</li>
</ul>
</li>
<li>11 Feb 2005: v0.3 released<ul>
<li>Support for LEDA-5.0 added, see INSTALL file</li>
</ul>
</li>
<li>19 Oct 2004: v0.2 released</li>
<li>23 Sep 2004: v0.1 released containing implementation of rank-maximal matchings</li>
</ul>
<h1><a class="anchor" id="down_sec"></a>
Download</h1>
<ul>
<li>Source package (v0.7). [<a href="https://github.com/d-michail/mosp/archive/mosp-0.7.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.6). [<a href="https://github.com/d-michail/mosp/archive/mosp-0.6.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.5). [<a href="https://github.com/d-michail/mosp/archive/mosp-0.5.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.3). [<a href="https://github.com/d-michail/mosp/archive/mosp-0.3.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.2). [<a href="https://github.com/d-michail/mosp/archive/mosp-0.2.tar.gz">tar.gz</a>]</li>
</ul>
<h1><a class="anchor" id="source_sec"></a>
Source</h1>
<p>The repository can be found at <a href="https://github.com/d-michail/mosp">github</a>.</p>
<h1><a class="anchor" id="ex_sec"></a>
Code Example</h1>
<h2><a class="anchor" id="ex_rankmaximal"></a>
Rank-Maximal Matchings</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mosp_8h.html">LEP/mosp/mosp.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    leda::graph G;</div><div class="line"></div><div class="line">    <span class="comment">// construct simple, loopfree, bipartite graph G </span></div><div class="line"></div><div class="line">    leda::edge_array&lt;int&gt; rank(G, 1);</div><div class="line"></div><div class="line">    <span class="comment">// fill up ranks</span></div><div class="line"></div><div class="line">    leda::list&lt; leda::edge &gt; M = <a class="code" href="group__rankmax.html#ga4a5b62a58c1a83375909a3bed9fef74f">mosp::BI_RANK_MAX_MATCHING</a>( G, rank );</div><div class="line"></div><div class="line">    <span class="comment">// do something with M</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="ex_popular"></a>
Popular Matchings</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mosp_8h.html">LEP/mosp/mosp.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">     leda::graph G;</div><div class="line"></div><div class="line">     <span class="comment">// construct simple, loopfree, bipartite graph G </span></div><div class="line"></div><div class="line">     leda::list&lt; leda::node &gt; A, B;</div><div class="line"></div><div class="line">     <span class="comment">// add left partition nodes to A, right partition nodes to B</span></div><div class="line"></div><div class="line">     leda::edge_array&lt;int&gt; rank(G, 1);</div><div class="line"></div><div class="line">     <span class="comment">// fill up ranks</span></div><div class="line"></div><div class="line">     leda::list&lt; leda::edge &gt; M;</div><div class="line">     <span class="keywordtype">bool</span> is_popular = <a class="code" href="group__popular.html#ga1bf791e7083f509d984faed5590da25f">mosp::BI_POPULAR_MATCHING</a>( G, A, B, rank, M );</div><div class="line"></div><div class="line">         <span class="comment">// do something with M</span></div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="ex_notunpopular"></a>
Popular Approximation</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mosp_8h.html">LEP/mosp/mosp.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    leda::graph G;</div><div class="line"></div><div class="line">    <span class="comment">// construct simple, loopfree, bipartite graph G </span></div><div class="line"></div><div class="line">    leda::list&lt; leda::node &gt; A, B;</div><div class="line"></div><div class="line">    <span class="comment">// add left partition nodes to A, right partition nodes to B</span></div><div class="line"></div><div class="line">    leda::edge_array&lt;int&gt; rank(G, 1);</div><div class="line"></div><div class="line">    <span class="comment">// fill up ranks</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> phase;</div><div class="line">    leda::list&lt; leda::edge &gt; M;</div><div class="line">    <span class="keywordtype">bool</span> is_popular = <a class="code" href="group__popular.html#ga24c7d24994ae7bba794c0d6efe531575">mosp::BI_APPROX_POPULAR_MATCHING</a>( G, A, B, rank, M, phase );</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> unpopularity_factor;</div><div class="line">    <span class="keywordflow">if</span> ( <a class="code" href="group__popular.html#ga02c0a9d764d55fbb302dc51dd02d633c">mosp::BI_UNPOPULARITY_FACTOR</a>( G, A, B, rank, M, unpopularity_factor ) )</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;unpopularity factor = &quot;</span> &lt;&lt; unpopularity_factor &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// do something with M</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">} </div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
